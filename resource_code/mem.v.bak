module mem(                   //使用大段模式
    input clk,
    input [31:0] alu_result,
    input [31:0] din,
    input MemWrite,
    input MemRead,
    input MemtoReg,
    input [1:0] mem_sel,
    output [31:0] dout
);

reg [7:0] ram_a[0:1023];
reg [7:0] ram_b[0:1023];
reg [7:0] ram_c[0:1023];
reg [7:0] ram_d[0:1023];
reg [31:0] data_out;

//读数据
always @(*) begin
    if(MemRead) 
        data_out <= {ram_d[alu_result[9:2]],ram_c[alu_result[9:2]],ram_b[alu_result[9:2]],ram_a[alu_result[9:2]]};                  //取低10位 因为log1024/log2 = 10  
    else
        data_out <= 32'h00000000;
end

//写数据     在时钟上升沿
always @(posedge clk) begin
    if (MemWrite) begin
        case (mem_sel)
            2'b00: ram_a[alu_result[9:2]] <= ram_a[alu_result[9:2]];              //sc指令先不实现
            2'b01:begin                                                         //sb
                ram_a[alu_result[9:2]] <= din[7:0];                      
            end
            2'b10:begin                                                         //sh
                ram_a[alu_result[9:2]] <= din[0:7];
                ram_b[alu_result[9:2]] <= din[8:15];
            end
            2'b11:begin
                ram_a[alu_result[9:2]] <= din[0:7];
                ram_b[alu_result[9:2]] <= din[8:15];
                ram_c[alu_result[9:2]] <= din[16:23];
                ram_d[alu_result[9:2]] <= din[24:31];
            end
            default: ram_a[alu_result[9:2]] <= ram_a[alu_result[9:2]];
        endcase 
    end
    else 
        ram_a[alu_result[9:2]] <= ram_a[alu_result[9:2]];
end

//决定哪个数据写回寄存器堆      写回
assign dout = (MemtoReg == 1'b1)?data_out:alu_result;


endmodule 